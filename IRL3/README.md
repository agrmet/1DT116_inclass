# IRL3 Data-level-parallelism (SIMD) In-class codes

## References to intrinsics
* [Arm intrinsics](https://developer.arm.com/architectures/instruction-sets/intrinsics/) - filter for NEON instructions. [Arm manual](https://developer.arm.com/documentation/den0018/a/NEON-Intrinsics) has some examples too.
* [Intel intrinsics](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html) - filter for all of the `SSE family` and just the `AVX` within the `AVX family`.

In this module we will look at two tasks.

## 1. Converting a color image into a grayscale image.
To do this, you will be working with a PPM image...

### Information about the PPM format and generating your own PPM images.

**This is interesting information, but not mandatory to read through, if you
want to get started. I have implemented most of the reading from PPM and
writing to PGM in the provided code. Skip this subsection if you want to get
started**

We will use the [PPM format](https://netpbm.sourceforge.net/doc/ppm.html) which is a part of the [Netpbm package](https://netpbm.sourceforge.net).
This is a raster graphics format where each pixel is represented by Red,
Green, and Blue values. The image file dictates how many bits are used to
represent each RGB value in a pixel, but 255 (0-255 meaning a total of 1B)
seems to be the default value for the images generated by tools of the Netpbm
package. 

To install the Netpbm package and some of the conversion tools it provides,
one can use the following functions on Ubuntu or Mac.

``` 
# on a Mac
$ brew install netpbm

#Or on Ubuntu (or Debian based systems)
$ sudo apt install netpbm
```

Then you can use the `jpegtopnm` command to convert a jpeg image of your choosing to ppm.

```
$ jpegtopnm image.jpg > image.ppm
```

You can also use the Mac Preview app or `eog` app on GNOME (works on UPPMAX,
but remember to forward X) to view the image that you are working on.

Furthermore, you can use the [PGM format](https://netpbm.sourceforge.net/doc/pgm.html) when you save the grayscale image.
This format provides one byte per pixel and holds the intensity of the
grayscale image.

### Getting started
Run the `setup_img_links.sh` to setup symbolic links to the images that
I have uploaded into our project shared directory.

```
./setup_img_links.sh
```

If you are working on your own computers, you can download the images
from Studium. Look for `images.tar.bz2` in the modules page under IRL3.

Now, you are ready to start coding.
There are three parts of this program:

1. `grayscale_image.c`: This is the main file you will be working on.
Fill in the `grayscale_image_simd_{sse|avx|neon|neon_fp16}` functions.
2. `ppm.c` and `ppm.h`: This function holds everything to do with the PPM format.
Any reading of actual ppm files, any writing back into pgm files are done here.
We also cheat here. Usually PPM files have R, G, and B value for each pixel interleaved.
This is challenging to work with SIMD as we then need to work with swizzling
data in different parts of the vector register lane, etc.
Therefore, to make this simpler, I have organized the on-memory representation as
an array of Red pixels, another array of Green pixels and finally an array of blue pixels.
This will make SIMD processing much easier!
3. `common.c` and `common.h` At this point, it only holds timer related functions.

Now your implementatin of `grayscale_image_simd_{sse|avx|neon|neon_fp16}` merely
needs to read in each pixel and its three colors (R,G,B) values and calculate the
grayscale value. Use the following formula.
One can use the [ITU-R BT.709](https://en.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems) standard to convert RGB to grayscale.

```
grayscale = R*0.21 + G*0.72 + B*0.07
```

Once you have implemented your version, say `avx`. You can run your program using the following method:

```
./grayscale_image avx IMG_5440.ppm
```

Then check the generated grayscale image that is in the PGM format. You can use `eog` that is installed on rackham.
You need to have x-forwarding set up to use this.

```
eog IMG_5440.pgm
```

Compare with the IMG\_5440.ppm (again using eog) and you should find that they are similar and PGM file is the gray-scale version of the PPM image.

If you are working from a Mac, instead of eog, you can use the Preview app to view it. From the terminal you can invoke the Preview app by running the following command:

```
open IMG_5440.pgm
```

Once you are ready and fairly convinced that your code is working well, you can run timing experiments by using the following command

```
make run_grayscale_x86 # if you are on an x86 machine, or crocodile
make run_grayscale_arm # if you are working on your Mac with an Apple silicon
```

### Side note for Arm people
Arm CPUs (at least the M1 and later Macs) support fp16. For the purpose of
this lab, we don't need FP32 precision (you can confirm this later on).

And so, there is another version of the neon code you can implement using the
`float16_t`. The PPMImage struct also holds `data_fp16` and
`grayscale_data_fp16` arrays that hold the `float16_t` elements. You can use
these to implement your `neon_fp16` implementation.

Finally, for the `float16_t` results, the provided code will in addition to
the normal `IMG_XXX.pgm` files, also create a `IMG_XXXX_fp16.pgm` so that you
can compare your FP16 and FP32 results. (I could not discern a difference
between the two, but you may have better vision sensitivity than I do ;)

### Hint for everyone
Think about what type of operations you need to do for this task.
All you need to do is set SIMD registers with a certain value, load, multiply, add, and store. 
E.g. `_mm512_load_ps()` or `vld1q_f32()` to get you started!  
Setting all values of the elements in the vector can be done using the `_mm512_set1_ps()` or `vdupq_n_f32()`.

## 2. Monte-carlo Pi simulation
Generate many 100s of millions of random points with ranges [0,1] for both the x and y value.
Then go through each of the random point and measure the euclidean distance between the point and the origin.
If the distance is less-than or equal to 1, then you can say that this point lies within the radius of the circle.
(Assume that we have a circle `x^2 + y^2 = 1` and we are only looking at the first quadrant)
Now, you can get a portion out of the total points, how many lie within the distance of 1 and multiply by 4 and you get pi.
(Because the area of a circle of radius of 1 is pi).

Implement this in SIMD! I have implemented the non-vectorized version for you.

Oh and the file you will work on is `pi.c`.

Once you `make pi` you can run say your `neon` version using the following instruction.

```
./pi neon
```

If you have implemented both sse and avx, or just neon; you can compare non-vectorized (serial) and your vectorized version using the following command:

```
make run_pi_x86 # if you are on an x86 machine, or rackham/snowy
make run_pi_arm # if you are working on your Mac with an Apple silicon
```

Make sure to check that the Pi value printed for your SIMD version is relatively close to the Pi value from the serial version!
